# 闭包

*概念*
  closure 是js的重要语法特性，能访问**自由变量**的函数叫做闭包

  当一个内部函数访问了它所在的外部函数作用域中的变量，即使外部函数已经执行完毕，这些变量也不会释放，而是停留在内存中，像放进背包一样，内部函数还可以调用，这种机制叫闭包
  《你不知道的JavaScript》中，闭包 = 函数 + 词法作用域(本质)

  形成条件：函数嵌套函数，内部函数可以在外界访问（返回或挂载在全局）
    立即执行函数、块级作用域 + 定时器

*底层原理*
  词法作用域（Lexical Scope）
  JavaScript 在定义函数时，就确定了函数能访问哪些变量（作用域在声明阶段就决定了）

  作用域链（Scope Chain）：内部函数在查找变量时，会沿着作用域链向上查找外层变量
    变量持久化：由于闭包函数依旧引用自由变量，js引擎的 GC（垃圾回收机制）认为，这些外部变量还在用，所以不 会销毁，导致变量值持久存在。

*模型图*
  [Glabal Scope]
        ⬆️
  [Outer Function Scope]
        ⬆️
  [Inner Function Scope]

*业务场景*
  - 数据私有化
      封装类或函数的复杂性
  - 防抖节流
  - 循环绑定事件

    setTime()不一定是闭包，可将 var改成 let实现闭包
    ```js
    for(var i=0;i<3;i++){
        setTime(()=>{
            console.log(i)
        },1000)
    }
    ```
    立即执行函数 IIFE

  - 缓存记忆优化
    ```js
    function memoize(fn){
        const cache={}
        return function(key){
            if(cache[key] return cache[key])
            const result = fn(key)
            cache[key]=result
            return result
        }
    }
    ```

  - 柯里化
      怎么将一个接收多个参数的函数，转换为一系列只接受一个参数的函数链
  - 偏函数...

*总结*
  闭包是函数与其外部词法作用域的组合，他让函数在外部作用域执行完后依然能访问里面的变量
  本质是作用域链导致变量持久化，在工程中常用于数据私有化、防抖/节流、事件绑定、缓存优化等。

  我在项目中经常用闭包减少全局变量污染，但也注意可能带来内存泄漏，不需要手动释放应用


*setTimeout 里的回调函数是闭包吗？*
  从闭包的定义上来说，setTimeout 的回调一般会形成闭包，因为它在创建的时候，捕获了外层函数的变量，即使外层函数执行结束，变量依旧可以访问。

  但严格来说，setTimeout 的回调函数本身不是闭包，因为闭包的本质是函数 + 词法环境的绑定。

  是否是闭包，取决于回调是否会调用自由变量，而不是setTimeout API

  **举例：**
  在循环定时器的时候，用 let声明块级作用域或 IIFE闭包定时器回调，是闭包。

